<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>rok4_tools.tmsizer_utils.processors.map API documentation</title>
<meta name="description" content="Provide processor tranforming data. Output data is emitted as the input processor reading progresses …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rok4_tools.tmsizer_utils.processors.map</code></h1>
</header>
<section id="section-intro">
<p>Provide processor tranforming data. Output data is emitted as the input processor reading progresses</p>
<p>The module contains the following classes:</p>
<ul>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor">Gettile2tileindexProcessor</a></code> - Extract tile index from a WMTS GetTile URL</li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor">Tileindex2gettileProcessor</a></code> - Generate WMTS GetTile query parameters from tile index</li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor">Tileindex2pointProcessor</a></code> - Generate the tile's center coordinates from tile index</li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor">Geometry2tileindexProcessor</a></code> - Generate all tiles' indices intersecting the input geometry</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor"><code class="flex name class">
<span>class <span class="ident">Geometry2tileindexProcessor</span></span>
<span>(</span><span>input: <a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a>, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Processor generating the tile's center coordinates from tile index</p>
<p>Accepted input format is "GEOMETRY" and output format is "TILE_INDEX"</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
<dt><strong><code>__geometry_format</code></strong> :&ensp;<code>str</code></dt>
<dd>Format of input string geometries. "WKT", "WKB" or "GeoJSON"</dd>
<dt><strong><code>__level</code></strong> :&ensp;<code>str</code></dt>
<dd>Tile matrix identifier to define intersecting tiles</dd>
</dl>
<p>Constructor method</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
<dt><strong><code>**format</code></strong> :&ensp;<code>str</code></dt>
<dd>Format of input string geometries. "WKT", "WKB" or "GeoJSON"</dd>
<dt><strong><code>**level</code></strong> :&ensp;<code>str</code></dt>
<dd>Tile matrix identifier to define intersecting tiles</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Input format is not allowed</dd>
<dt><code>KeyError</code></dt>
<dd>A mandatory option is missing</dd>
<dt><code>ValueError</code></dt>
<dd>A mandatory option is not valid</dd>
<dt><code>ValueError</code></dt>
<dd>Provided level is not in the pivot TMS</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry2tileindexProcessor(Processor):
    &#34;&#34;&#34;Processor generating the tile&#39;s center coordinates from tile index

    Accepted input format is &#34;GEOMETRY&#34; and output format is &#34;TILE_INDEX&#34;

    Attributes:
        __input (Processor): Processor from which data is read
        __geometry_format (str): Format of input string geometries. &#34;WKT&#34;, &#34;WKB&#34; or &#34;GeoJSON&#34;
        __level (str): Tile matrix identifier to define intersecting tiles
    &#34;&#34;&#34;

    input_formats_allowed = [&#34;GEOMETRY&#34;]
    geometry_formats_allowed = [&#34;WKT&#34;, &#34;WKB&#34;, &#34;GeoJSON&#34;]

    def __init__(self, input: Processor, **options):
        &#34;&#34;&#34;Constructor method

        Args:
            input (Processor): Processor from which data is read
            **format (str): Format of input string geometries. &#34;WKT&#34;, &#34;WKB&#34; or &#34;GeoJSON&#34;
            **level (str): Tile matrix identifier to define intersecting tiles

        Raises:
            ValueError: Input format is not allowed
            KeyError: A mandatory option is missing
            ValueError: A mandatory option is not valid
            ValueError: Provided level is not in the pivot TMS
        &#34;&#34;&#34;  

        if input.format not in self.input_formats_allowed:
            raise ValueError(f&#34;Input format {input.format} is not handled for Geometry2tileindexProcessor : allowed formats are {self.input_formats_allowed}&#34;)

        super().__init__(&#34;TILE_INDEX&#34;)

        self.__input = input

        try:

            if options[&#34;format&#34;] not in self.geometry_formats_allowed:
                raise ValueError(f&#34;Option &#39;format&#39; for an input geometry is not handled ({options[&#39;format&#39;]}) : allowed formats are {self.geometry_formats_allowed}&#34;)

            self.__geometry_format = options[&#34;format&#34;]

            if self.tms.get_level(options[&#34;level&#34;]) is None:
                raise ValueError(f&#34;Provided level is not in the TMS&#34;)

            self.__level = options[&#34;level&#34;]

        except KeyError as e:
            raise KeyError(f&#34;Option {e} is required to generate tile indices from geometries&#34;)

    def process(self) -&gt; Iterator[Tuple[str, int, int]]:
        &#34;&#34;&#34;Read a geometry from the input processor and extract tile index

        Geometry is parsed according to provided format. To determine intersecting tiles, geometry have to be a Polygon or a MultiPolygon. 
        For an input geometry, all intersecting tiles for the provided level are yielded

        Examples:

            Get intersecting tiles&#39; indices

                from rok4_tools.tmsizer_utils.processors.map import Geometry2tileindexProcessor

                try:
                    # Creation of Processor source_processor with format GEOMETRY
                    processor = Geometry2tileindexProcessor(source_processor, level=&#34;15&#34;, format=&#34;GeoJSON&#34; )
                    for item in processor.process():
                        (level, col, row) = item

                except Exception as e:
                    print(&#34;{e}&#34;)

        Yields:
            Iterator[Tuple[str, int, int]]: Tile index (level, col, row)
        &#34;&#34;&#34;  

        tile_matrix = self.tms.get_level(self.__level)

        if self.__input.format == &#34;GEOMETRY&#34;:

            for item in self.__input.process():
                self._processed += 1

                try:
                    geom = None
                    if self.__geometry_format == &#34;WKT&#34;:
                        geom = ogr.ForceToMultiPolygon(ogr.CreateGeometryFromWkt(item))
                    elif self.__geometry_format == &#34;GeoJSON&#34;:
                        geom = ogr.ForceToMultiPolygon(ogr.CreateGeometryFromJson(item))
                    elif self.__geometry_format == &#34;WKB&#34;:
                        geom = ogr.ForceToMultiPolygon(ogr.CreateGeometryFromWkb(item))
                
                    for i in range(0, geom.GetGeometryCount()):
                        g = geom.GetGeometryRef(i)
                        xmin, xmax, ymin, ymax = g.GetEnvelope()
                        col_min, row_min, col_max, row_max = tile_matrix.bbox_to_tiles((xmin, ymin, xmax, ymax))

                        for col in range(col_min, col_max + 1):
                            for row in range(row_min, row_max + 1):
                                tg = bbox_to_geometry(tile_matrix.tile_to_bbox(col, row))
                                if g.Intersects(tg):
                                    yield (self.__level, col, row)

                except Exception as e:
                    # La géométrie n&#39;est pas valide, on la passe simplement
                    print(e)
                    continue

    def __str__(self) -&gt; str:
        return f&#34;Geometry2tileindexProcessor : {self._processed} {self.__input.format} items processed (format {self.__geometry_format}), extracting intersecting tile&#39;s indices&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.geometry_formats_allowed"><code class="name">var <span class="ident">geometry_formats_allowed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.input_formats_allowed"><code class="name">var <span class="ident">input_formats_allowed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self) ‑> Iterator[Tuple[str, int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read a geometry from the input processor and extract tile index</p>
<p>Geometry is parsed according to provided format. To determine intersecting tiles, geometry have to be a Polygon or a MultiPolygon.
For an input geometry, all intersecting tiles for the provided level are yielded</p>
<h2 id="examples">Examples</h2>
<p>Get intersecting tiles' indices</p>
<pre><code>from rok4_tools.tmsizer_utils.processors.map import Geometry2tileindexProcessor

try:
    # Creation of Processor source_processor with format GEOMETRY
    processor = Geometry2tileindexProcessor(source_processor, level="15", format="GeoJSON" )
    for item in processor.process():
        (level, col, row) = item

except Exception as e:
    print("{e}")
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Tuple[str, int, int]]</code></dt>
<dd>Tile index (level, col, row)</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></b></code>:
<ul class="hlist">
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.format" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.format">format</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms">set_tms</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.tms">tms</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor"><code class="flex name class">
<span>class <span class="ident">Gettile2tileindexProcessor</span></span>
<span>(</span><span>input: <a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a>, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Processor extracting tile index from a WMTS GetTile URL</p>
<p>Accepted input format is "GETTILE_PARAMS" and output format is "TILE_INDEX"</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
<dt><strong><code>__levels</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>Tile matrix identifier(s) to filter data</dd>
<dt><strong><code>__layers</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>Layer(s) to filter data</dd>
</dl>
<p>Constructor method</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
<dt><strong><code>**levels</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Tile matrix identifier(s) to filter data</dd>
<dt><strong><code>**layers</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Layer(s) to filter data</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Input format is not allowed</dd>
<dt><code>ValueError</code></dt>
<dd>Provided level is not in the pivot TMS</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gettile2tileindexProcessor(Processor):
    &#34;&#34;&#34;Processor extracting tile index from a WMTS GetTile URL

    Accepted input format is &#34;GETTILE_PARAMS&#34; and output format is &#34;TILE_INDEX&#34;

    Attributes:
        __input (Processor): Processor from which data is read
        __levels (List[str], optional): Tile matrix identifier(s) to filter data
        __layers (List[str], optional): Layer(s) to filter data
    &#34;&#34;&#34;

    input_formats_allowed = [&#34;GETTILE_PARAMS&#34;]

    def __init__(self, input: Processor, **options):
        &#34;&#34;&#34;Constructor method

        Args:
            input (Processor): Processor from which data is read
            **levels (str, optional): Tile matrix identifier(s) to filter data
            **layers (str, optional): Layer(s) to filter data

        Raises:
            ValueError: Input format is not allowed
            ValueError: Provided level is not in the pivot TMS
        &#34;&#34;&#34;        

        if input.format not in self.input_formats_allowed:
            raise ValueError(f&#34;Input format {input.format} is not handled for Gettile2tileindexProcessor : allowed formats are {self.input_formats_allowed}&#34;)

        super().__init__(&#34;TILE_INDEX&#34;)

        self.__input = input
        if &#34;levels&#34; in options.keys():
            self.__levels = options[&#34;levels&#34;].split(&#34;,&#34;)
            for l in self.__levels:
                if self.tms.get_level(l) is None:
                    raise ValueError(f&#34;The provided level &#39;{l}&#39; is not in the TMS&#34;)
        else:
            self.__levels = None

        self.__input = input
        if &#34;layers&#34; in options.keys():
            self.__layers = options[&#34;layers&#34;].split(&#34;,&#34;)
        else:
            self.__layers = None

    def process(self) -&gt; Iterator[Tuple[str, int, int]]:
        &#34;&#34;&#34;Read an item from the input processor and extract tile index

        Used query parameters are TILEMATRIXSET, TILEMATRIX, TILECOL and TILEROW. If one is missing, item is passed. 
        TILEMATRISET have to be the pivot TMS&#39;s name (or just preffixed by its name). TILEMATRIX have to be present in the pivot TMS. 
        If filtering levels are provided, unmatched TILEMATRIX are passed. If filtering layers are provided, unmatched LAYER are passed.

        Examples:

            Get tile index

                from rok4_tools.tmsizer_utils.processors.map import Gettile2tileindexProcessor

                try:
                    # Creation of Processor source_processor with format GETTILE_PARAMS
                    processor = Gettile2tileindexProcessor(source_processor, level=&#34;19&#34; )
                    for item in processor.process():
                        (level, col, row) = item

                except Exception as e:
                    print(&#34;{e}&#34;)

        Yields:
            Iterator[Tuple[str, int, int]]: Tile index (level, col, row)
        &#34;&#34;&#34;  

        if self.__input.format == &#34;GETTILE_PARAMS&#34;:
            for item in self.__input.process():
                self._processed += 1

                qs = parse_qs(urlparse(item.upper()).query)
                try:

                    # On se limite à un niveau et ce n&#39;est pas celui de la requête
                    if self.__levels is not None and qs[&#34;TILEMATRIX&#34;][0] not in self.__levels:
                        continue

                    # On se limite à une couche et ce n&#39;est pas celle de la requête
                    if self.__layers is not None and qs[&#34;LAYER&#34;][0] not in self.__layers:
                        continue

                    # La requête n&#39;utilise pas le TMS en entrée
                    if qs[&#34;TILEMATRIXSET&#34;][0] != self.tms.name and not qs[&#34;TILEMATRIXSET&#34;][0].startswith(f&#34;{self.tms.name}_&#34;):
                        continue

                    # La requête demande un niveau que le TMS ne possède pas
                    if self.tms.get_level(qs[&#34;TILEMATRIX&#34;][0]) is None:
                        continue

                    yield (str(qs[&#34;TILEMATRIX&#34;][0]),int(qs[&#34;TILECOL&#34;][0]),int(qs[&#34;TILEROW&#34;][0]))
                except Exception as e:
                    # La requête n&#39;est pas un gettile ou n&#39;est pas valide, il manque un paramètre, ou il a un mauvais format
                    # on la passe simplement
                    pass

    def __str__(self) -&gt; str:
        return f&#34;Gettile2tileindexProcessor : {self._processed} {self.__input.format} items processed, extracting tile&#39;s indices&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.input_formats_allowed"><code class="name">var <span class="ident">input_formats_allowed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self) ‑> Iterator[Tuple[str, int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read an item from the input processor and extract tile index</p>
<p>Used query parameters are TILEMATRIXSET, TILEMATRIX, TILECOL and TILEROW. If one is missing, item is passed.
TILEMATRISET have to be the pivot TMS's name (or just preffixed by its name). TILEMATRIX have to be present in the pivot TMS.
If filtering levels are provided, unmatched TILEMATRIX are passed. If filtering layers are provided, unmatched LAYER are passed.</p>
<h2 id="examples">Examples</h2>
<p>Get tile index</p>
<pre><code>from rok4_tools.tmsizer_utils.processors.map import Gettile2tileindexProcessor

try:
    # Creation of Processor source_processor with format GETTILE_PARAMS
    processor = Gettile2tileindexProcessor(source_processor, level="19" )
    for item in processor.process():
        (level, col, row) = item

except Exception as e:
    print("{e}")
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Tuple[str, int, int]]</code></dt>
<dd>Tile index (level, col, row)</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></b></code>:
<ul class="hlist">
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.format" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.format">format</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms">set_tms</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.tms">tms</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor"><code class="flex name class">
<span>class <span class="ident">Tileindex2gettileProcessor</span></span>
<span>(</span><span>input: <a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Processor generating WMTS GetTile query parameters from tile index</p>
<p>Accepted input format is "TILE_INDEX" and output format is "GETTILE_PARAMS"</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
</dl>
<p>Constructor method</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Input format is not allowed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tileindex2gettileProcessor(Processor):
    &#34;&#34;&#34;Processor generating WMTS GetTile query parameters from tile index

    Accepted input format is &#34;TILE_INDEX&#34; and output format is &#34;GETTILE_PARAMS&#34;

    Attributes:
        __input (Processor): Processor from which data is read
    &#34;&#34;&#34;

    input_formats_allowed = [&#34;TILE_INDEX&#34;]

    def __init__(self, input: Processor):
        &#34;&#34;&#34;Constructor method

        Args:
            input (Processor): Processor from which data is read

        Raises:
            ValueError: Input format is not allowed
        &#34;&#34;&#34;  

        if input.format not in self.input_formats_allowed:
            raise ValueError(f&#34;Input format {input.format} is not handled for Tileindex2gettileProcessor : allowed formats are {self.input_formats_allowed}&#34;)

        super().__init__(&#34;GETTILE_PARAMS&#34;)

        self.__input = input

    def process(self) -&gt; Iterator[str]:
        &#34;&#34;&#34;Read a tile index from the input processor and generate WMTS GetTile query parameters

        Examples:

            Get GetTile query parameters

                from rok4_tools.tmsizer_utils.processors.map import Tileindex2gettileProcessor

                try:
                    # Creation of Processor source_processor with format TILE_INDEX
                    processor = Tileindex2gettileProcessor(source_processor)
                    for item in processor.process():
                        query_parameters = item

                except Exception as e:
                    print(&#34;{e}&#34;)

        Yields:
            Iterator[str]: GetTile query parameters TILEMATRIXSET=&lt;tms&gt;&amp;TILEMATRIX=&lt;level&gt;&amp;TILECOL=&lt;col&gt;&amp;TILEROW=&lt;row&gt;
        &#34;&#34;&#34;  

        if self.__input.format == &#34;TILE_INDEX&#34;:
            for item in self.__input.process():
                self._processed += 1

                (level, col, row) = item

                yield f&#34;TILEMATRIXSET={self.tms.name}&amp;TILEMATRIX={level}&amp;TILECOL={col}&amp;TILEROW={row}&#34;

    def __str__(self) -&gt; str:
        return f&#34;Tileindex2gettileProcessor : {self._processed} {self.__input.format} items processed, generating GetTile&#39;s query parameters&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.input_formats_allowed"><code class="name">var <span class="ident">input_formats_allowed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Read a tile index from the input processor and generate WMTS GetTile query parameters</p>
<h2 id="examples">Examples</h2>
<p>Get GetTile query parameters</p>
<pre><code>from rok4_tools.tmsizer_utils.processors.map import Tileindex2gettileProcessor

try:
    # Creation of Processor source_processor with format TILE_INDEX
    processor = Tileindex2gettileProcessor(source_processor)
    for item in processor.process():
        query_parameters = item

except Exception as e:
    print("{e}")
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[str]</code></dt>
<dd>GetTile query parameters TILEMATRIXSET=<tms>&amp;TILEMATRIX=<level>&amp;TILECOL=<col>&amp;TILEROW=<row></dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></b></code>:
<ul class="hlist">
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.format" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.format">format</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms">set_tms</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.tms">tms</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor"><code class="flex name class">
<span>class <span class="ident">Tileindex2pointProcessor</span></span>
<span>(</span><span>input: <a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Processor generating the tile's center coordinates from tile index</p>
<p>Accepted input format is "TILE_INDEX" and output format is "POINT"</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
</dl>
<p>Constructor method</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>Processor</code></dt>
<dd>Processor from which data is read</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Input format is not allowed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tileindex2pointProcessor(Processor):
    &#34;&#34;&#34;Processor generating the tile&#39;s center coordinates from tile index

    Accepted input format is &#34;TILE_INDEX&#34; and output format is &#34;POINT&#34;

    Attributes:
        __input (Processor): Processor from which data is read
    &#34;&#34;&#34;

    input_formats_allowed = [&#34;TILE_INDEX&#34;]

    def __init__(self, input: Processor):
        &#34;&#34;&#34;Constructor method

        Args:
            input (Processor): Processor from which data is read

        Raises:
            ValueError: Input format is not allowed
        &#34;&#34;&#34;  

        if input.format not in self.input_formats_allowed:
            raise ValueError(f&#34;Input format {input.format} is not handled for Tileindex2pointProcessor : allowed formats are {self.input_formats_allowed}&#34;)

        super().__init__(&#34;POINT&#34;)

        self.__input = input

    def process(self) -&gt; Iterator[Tuple[float, float]]:
        &#34;&#34;&#34;Read a tile index from the input processor and generate the tile&#39;s center coordinates

        Examples:

            Get tile&#39;s center coordinates

                from rok4_tools.tmsizer_utils.processors.map import Tileindex2pointProcessor

                try:
                    # Creation of Processor source_processor with format TILE_INDEX
                    processor = Tileindex2pointProcessor(source_processor)
                    for item in processor.process():
                        (x, y) = item

                except Exception as e:
                    print(&#34;{e}&#34;)

        Yields:
            Iterator[Tuple[float, float]]: point coordinates (x,y)
        &#34;&#34;&#34;  

        if self.__input.format == &#34;TILE_INDEX&#34;:
            for item in self.__input.process():
                self._processed += 1

                (level, col, row) = item
                try:
                    bb = self.tms.get_level(level).tile_to_bbox(col, row)

                    x_center = bb[0] + (bb[2] - bb[0]) / 2;
                    y_center = bb[1] + (bb[3] - bb[1]) / 2;

                    yield (x_center, y_center)
                except Exception as e:
                    # Le niveau n&#39;est pas valide, on passe simplement
                    pass

    def __str__(self) -&gt; str:
        return f&#34;Tileindex2pointProcessor : {self._processed} {self.__input.format} items processed, extracting tile&#39;s center coordinates&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.input_formats_allowed"><code class="name">var <span class="ident">input_formats_allowed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self) ‑> Iterator[Tuple[float, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read a tile index from the input processor and generate the tile's center coordinates</p>
<h2 id="examples">Examples</h2>
<p>Get tile's center coordinates</p>
<pre><code>from rok4_tools.tmsizer_utils.processors.map import Tileindex2pointProcessor

try:
    # Creation of Processor source_processor with format TILE_INDEX
    processor = Tileindex2pointProcessor(source_processor)
    for item in processor.process():
        (x, y) = item

except Exception as e:
    print("{e}")
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Tuple[float, float]]</code></dt>
<dd>point coordinates (x,y)</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rok4_tools.tmsizer_utils.processors.processor.Processor" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor">Processor</a></b></code>:
<ul class="hlist">
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.format" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.format">format</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.set_tms">set_tms</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.processor.Processor.tms" href="processor.html#rok4_tools.tmsizer_utils.processors.processor.Processor.tms">tms</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rok4_tools.tmsizer_utils.processors" href="index.html">rok4_tools.tmsizer_utils.processors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor">Geometry2tileindexProcessor</a></code></h4>
<ul class="">
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.geometry_formats_allowed" href="#rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.geometry_formats_allowed">geometry_formats_allowed</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.input_formats_allowed" href="#rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.input_formats_allowed">input_formats_allowed</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.process" href="#rok4_tools.tmsizer_utils.processors.map.Geometry2tileindexProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor">Gettile2tileindexProcessor</a></code></h4>
<ul class="">
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.input_formats_allowed" href="#rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.input_formats_allowed">input_formats_allowed</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.process" href="#rok4_tools.tmsizer_utils.processors.map.Gettile2tileindexProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor">Tileindex2gettileProcessor</a></code></h4>
<ul class="">
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.input_formats_allowed" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.input_formats_allowed">input_formats_allowed</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.process" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2gettileProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor">Tileindex2pointProcessor</a></code></h4>
<ul class="">
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.input_formats_allowed" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.input_formats_allowed">input_formats_allowed</a></code></li>
<li><code><a title="rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.process" href="#rok4_tools.tmsizer_utils.processors.map.Tileindex2pointProcessor.process">process</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
